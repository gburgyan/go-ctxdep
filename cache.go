package ctxdep

import (
	"context"
	"reflect"
	"strings"
	"time"
)

// Keyable is an interface that can be implemented by a
// dependency to provide a unique key that can be used to cache the
// result of the dependency. Implementing this interface is required
// if you want to use the Cached() function.
type Keyable interface {
	// CacheKey returns a key that can be used to cache the result of a
	// dependency. The key must be unique for the given dependency.
	CacheKey() string
}

var keyableType = reflect.TypeOf((*Keyable)(nil)).Elem()

// Cache is an interface for a cache that can be used with the
// Cached() function. The cache must be safe for concurrent use.
// The cache is not required to support locking, but if it does not
// support locking then the generator function must be safe for
// concurrent use.
//
// Internally this saves the results of the generator function in the cache.
// While it is possible to persist the results, be aware that this may be tricky.
// The cache will be passed a slice of arbitrary pointers to the results of the
// generator function.
type Cache interface {
	// Get returns the value for the given key, or nil if the key is
	// not found.
	Get(ctx context.Context, key string) []any

	// SetTTL sets the value for the given key, and sets the TTL for
	// the key. If the TTL is 0, the key will not expire.
	SetTTL(ctx context.Context, key string, value []any, ttl time.Duration)

	// Lock locks the given key. If the key is already locked, this
	// will block until the key is unlocked. The returned function
	// must be called to unlock the key. This is used to prevent
	// multiple goroutines from calling the generator function for
	// the same key. This is optional; if the cache does not support
	// locking, it can return nil or no-op function.
	Lock(ctx context.Context, key string) func()
}

// Cached returns a function that caches the result of the given
// generator function. The cache key is generated by calling the
// CacheKey() method on the key parameter. The cache key must be
// unique for the given dependency and the given context.
//
// The intent is that you can easily adapt any cache to work with
// this function. For example, if you have a Redis cache, you can
// implement the Cache interface by calling the Redis commands.
// Or you can use a library like Ristretto to implement the Cache
// interface by simply wrapping it.
func Cached(cache Cache, generator any, ttl time.Duration) any {
	genType := reflect.TypeOf(generator)
	if genType.Kind() != reflect.Func {
		panic("generator must be a function")
	}
	genValue := reflect.ValueOf(generator)

	// Gather the input and output types
	hasContext := false
	inTypes := make([]reflect.Type, genType.NumIn())
	for i := 0; i < genType.NumIn(); i++ {
		in := genType.In(i)
		if in.ConvertibleTo(contextType) {
			hasContext = true
		} else if !in.ConvertibleTo(keyableType) {
			panic("generator must take a parameters of context or Keyable")
		}
		inTypes[i] = in
	}

	// If the generator does not take a context, add one. We'll remove
	// this later when we call the actual generator function.
	if !hasContext {
		inTypes = append(inTypes, contextType)
	}

	outTypes := make([]reflect.Type, genType.NumOut())
	for i := 0; i < genType.NumOut(); i++ {
		outTypes[i] = genType.Out(i)
	}

	returnTypeKey := makeCachePrefix(outTypes)

	cachedGeneratorFunc := reflect.FuncOf(inTypes, outTypes, false)

	return reflect.MakeFunc(cachedGeneratorFunc, func(args []reflect.Value) []reflect.Value {
		var ctx context.Context
		for _, arg := range args {
			if arg.CanConvert(contextType) {
				ctx = arg.Interface().(context.Context)
				break
			}
		}
		cacheKey := makeCacheKey(args) + "//" + returnTypeKey
		values := cache.Get(ctx, cacheKey)
		if values != nil {
			cachedValueIndex := 0 // Note that we don't cache errors, so the index can differ.
			returnVals := make([]reflect.Value, len(outTypes))
			for i, outType := range outTypes {
				if outType.ConvertibleTo(errorType) {
					// The cached results should not contain errors, so just make nil errors.
					nilErr := reflect.Zero(outType)
					returnVals[i] = nilErr
				} else {
					val := reflect.New(outType).Elem()
					cachedValue := reflect.ValueOf(values[cachedValueIndex])
					cachedValueIndex++
					val.Set(cachedValue)
					returnVals[i] = val
				}
			}
			return returnVals
		}

		// If the cache supports locking, lock the key.
		unlock := cache.Lock(ctx, cacheKey)
		if unlock != nil {
			// If we have an unlocker, unlock the key when we return.
			defer unlock()
		}

		// If we added a context, then it'll be at the end. Remove it if we added it.
		funcArgs := args
		if !hasContext {
			funcArgs = funcArgs[:len(funcArgs)-1]
		}
		results := genValue.Call(funcArgs)

		cacheVals := make([]any, 0)
		// Verify that the results are valid.
		for _, result := range results {
			if result.Type().ConvertibleTo(errorType) {
				if !result.IsNil() {
					// If there is an error, don't cache the result
					return results
				}
			} else if result.IsZero() {
				// If the result is nil, don't cache the result
				return results
			}
			cacheVals = append(cacheVals, result.Interface())
		}

		cache.SetTTL(ctx, cacheKey, cacheVals, ttl)
		return results
	}).Interface()
}

func makeCachePrefix(resultTypes []reflect.Type) string {
	builder := strings.Builder{}
	for _, resultType := range resultTypes {
		if resultType.ConvertibleTo(errorType) {
			continue
		}
		if builder.Len() > 0 {
			builder.WriteString(":")
		}
		builder.WriteString(resultType.Elem().Name())
	}
	return builder.String()
}

func makeCacheKey(args []reflect.Value) string {
	builder := strings.Builder{}
	for _, arg := range args {
		if arg.CanConvert(contextType) {
			continue
		}
		if builder.Len() > 0 {
			builder.WriteString(":")
		}
		if arg.CanConvert(keyableType) {
			builder.WriteString(arg.Convert(keyableType).Interface().(Keyable).CacheKey())
		}
	}
	return builder.String()
}
