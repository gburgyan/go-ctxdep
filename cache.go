package ctxdep

import (
	"reflect"
	"strings"
	"time"
)

// CacheKeyProvider is an interface that can be implemented by a
// dependency to provide a unique key that can be used to cache the
// result of the dependency.
type CacheKeyProvider interface {
	// CacheKey returns a key that can be used to cache the result of a
	// dependency. The key must be unique for the given dependency and
	// the given context. This should be a string that is unique for
	// the given dependency.
	CacheKey() string
}

var cacheKeyProviderType = reflect.TypeOf((*CacheKeyProvider)(nil)).Elem()

// Cache is an interface for a cache that can be used with the
// Cacheable() function.
type Cache interface {
	// Get returns the value for the given key, or nil if the key is
	// not found.
	Get(key string) any

	// SetTTL sets the value for the given key, and sets the TTL for
	// the key. If the TTL is 0, the key will not expire.
	SetTTL(key string, value any, ttl time.Duration)
}

// Cacheable returns a function that caches the result of the given
// generator function. The cache key is generated by calling the
// CacheKey() method on the key parameter. The cache key must be
// unique for the given dependency and the given context.
//
// This can be used as-is, or you can make your own and use this
// as an example. There are possibilities for optimization, such as
// only calling the generator function once if multiple goroutines
// are waiting for the same result.
//
// The intent is that you can easily adapt any cache to work with
// this function. For example, if you have a Redis cache, you can
// implement the Cache interface by calling the Redis commands.
// Or you can use a library like Ristretto to implement the Cache
// interface by simply wrapping it.
func Cacheable(cache Cache, generator any, ttl time.Duration) any {
	genType := reflect.TypeOf(generator)
	if genType.Kind() != reflect.Func {
		panic("generator must be a function")
	}
	genValue := reflect.ValueOf(generator)

	// Gather the input and output types
	inTypes := make([]reflect.Type, genType.NumIn())
	for i := 0; i < genType.NumIn(); i++ {
		in := genType.In(i)
		if !in.ConvertibleTo(contextType) {
			if !in.ConvertibleTo(cacheKeyProviderType) {
				panic("generator must take a parameters of context or CacheKeyProvider")
			}
		}
		inTypes[i] = in
	}

	outTypes := make([]reflect.Type, genType.NumOut())
	for i := 0; i < genType.NumOut(); i++ {
		outTypes[i] = genType.Out(i)
	}

	returnTypeKey := makeCachePrefix(outTypes)

	return reflect.MakeFunc(genType, func(args []reflect.Value) []reflect.Value {
		cacheKey := "DepCache:(" + makeCacheKey(args) + ")->" + returnTypeKey
		value := cache.Get(cacheKey)
		if value != nil {
			return value.([]reflect.Value)
		}

		results := genValue.Call(args)

		// Verify that the results are valid.
		for _, result := range results {
			if result.Type().ConvertibleTo(errorType) {
				if !result.IsNil() {
					// If there is an error, don't cache the result
					return results
				}
			}
		}

		cache.SetTTL(cacheKey, results, ttl)
		return results
	}).Interface()
}

func makeCachePrefix(resultTypes []reflect.Type) string {
	builder := strings.Builder{}
	for _, resultType := range resultTypes {
		if resultType.ConvertibleTo(errorType) {
			continue
		}
		if builder.Len() > 0 {
			builder.WriteString(":")
		}
		builder.WriteString(resultType.Elem().Name())
	}
	return builder.String()
}

func makeCacheKey(args []reflect.Value) string {
	builder := strings.Builder{}
	for _, arg := range args {
		if arg.CanConvert(contextType) {
			continue
		}
		if builder.Len() > 0 {
			builder.WriteString(":")
		}
		if arg.CanConvert(cacheKeyProviderType) {
			builder.WriteString(arg.Convert(cacheKeyProviderType).Interface().(CacheKeyProvider).CacheKey())
		}
	}
	return builder.String()
}
