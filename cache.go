package ctxdep

import (
	"context"
	"reflect"
	"time"
)

// CacheKeyProvider is an interface that can be implemented by a
// dependency to provide a unique key that can be used to cache the
// result of the dependency.
type CacheKeyProvider interface {
	// CacheKey returns a key that can be used to cache the result of a
	// dependency. The key must be unique for the given dependency and
	// the given context. The key must be a string or a value that can
	// be converted to a string.
	CacheKey() string
}

// Cache is an interface for a cache that can be used with the
// Cacheable() function.
type Cache interface {
	Get(key string) (any, bool)
	SetTTL(key string, value any, ttl time.Duration)
}

// Cacheable returns a function that caches the result of the given
// generator function. The cache key is generated by calling the
// CacheKey() method on the key parameter. The cache key must be
// unique for the given dependency and the given context.
//
// This can be used as-is, or you can make your own and use this
// as an example. There are possibilities for optimization, such as
// only calling the generator function once if multiple goroutines
// are waiting for the same result.
//
// The intent is that you can easily adapt any cache to work with
// this function. For example, if you have a Redis cache, you can
// implement the Cache interface by calling the Redis commands.
// Or you can use a library like Ristretto to implement the Cache
// interface by simply wrapping it.
func Cacheable[K CacheKeyProvider, V any](cache Cache, generator func(ctx context.Context, key K) (V, error), ttl time.Duration) func(ctx context.Context, key K) (V, error) {
	valueType := reflect.TypeOf([]V{}).Elem()
	uniquePrefix := "DepCache-" + valueType.Elem().Name() + ":"

	//f := reflect.FuncOf()
	//v := reflect.MakeFunc()
	//v.

	// Return a function that caches the result of the generator
	// function.
	return func(ctx context.Context, key K) (V, error) {
		cacheKey := uniquePrefix + key.CacheKey()
		if value, ok := cache.Get(cacheKey); ok {
			return value.(V), nil
		}
		value, err := generator(ctx, key)
		if err != nil {
			return reflect.New(valueType).Elem().Interface().(V), err
		}
		cache.SetTTL(cacheKey, value, ttl)
		return value, nil
	}
}
