package ctxdep

import (
	"reflect"
	"strings"
	"time"
)

// Cacheable is an interface that can be implemented by a
// dependency to provide a unique key that can be used to cache the
// result of the dependency. Implementing this interface is required
// if you want to use the Cached() function.
type Cacheable interface {
	// CacheKey returns a key that can be used to cache the result of a
	// dependency. The key must be unique for the given dependency.
	CacheKey() string
}

var cacheKeyProviderType = reflect.TypeOf((*Cacheable)(nil)).Elem()

// Cache is an interface for a cache that can be used with the
// Cached() function. The cache must be safe for concurrent use.
// The cache is not required to support locking, but if it does not
// support locking then the generator function must be safe for
// concurrent use.
//
// Internally this saves the results of the generator function in the cache.
// While it is possible to persist the results, be aware that this may be tricky
// since these are raw reflect.Value objects.
type Cache interface {
	// Get returns the value for the given key, or nil if the key is
	// not found.
	Get(key string) []reflect.Value

	// SetTTL sets the value for the given key, and sets the TTL for
	// the key. If the TTL is 0, the key will not expire.
	SetTTL(key string, value []reflect.Value, ttl time.Duration)

	// Lock locks the given key. If the key is already locked, this
	// will block until the key is unlocked. The returned function
	// must be called to unlock the key. This is used to prevent
	// multiple goroutines from calling the generator function for
	// the same key. This is optional; if the cache does not support
	// locking, it can return nil or no-op function.
	Lock(key string) func()
}

// Cached returns a function that caches the result of the given
// generator function. The cache key is generated by calling the
// CacheKey() method on the key parameter. The cache key must be
// unique for the given dependency and the given context.
//
// The intent is that you can easily adapt any cache to work with
// this function. For example, if you have a Redis cache, you can
// implement the Cache interface by calling the Redis commands.
// Or you can use a library like Ristretto to implement the Cache
// interface by simply wrapping it.
func Cached(cache Cache, generator any, ttl time.Duration) any {
	genType := reflect.TypeOf(generator)
	if genType.Kind() != reflect.Func {
		panic("generator must be a function")
	}
	genValue := reflect.ValueOf(generator)

	// Gather the input and output types
	inTypes := make([]reflect.Type, genType.NumIn())
	for i := 0; i < genType.NumIn(); i++ {
		in := genType.In(i)
		if !in.ConvertibleTo(contextType) {
			if !in.ConvertibleTo(cacheKeyProviderType) {
				panic("generator must take a parameters of context or Cacheable")
			}
		}
		inTypes[i] = in
	}

	outTypes := make([]reflect.Type, genType.NumOut())
	for i := 0; i < genType.NumOut(); i++ {
		outTypes[i] = genType.Out(i)
	}

	returnTypeKey := makeCachePrefix(outTypes)

	return reflect.MakeFunc(genType, func(args []reflect.Value) []reflect.Value {
		cacheKey := "DepCache:(" + makeCacheKey(args) + ")->" + returnTypeKey
		values := cache.Get(cacheKey)
		if values != nil {
			return values
		}

		// If the cache supports locking, lock the key.
		unlock := cache.Lock(cacheKey)
		if unlock != nil {
			// If we have an unlocker, unlock the key when we return.
			defer unlock()
		}

		results := genValue.Call(args)

		// Verify that the results are valid.
		for _, result := range results {
			if result.Type().ConvertibleTo(errorType) {
				if !result.IsNil() {
					// If there is an error, don't cache the result
					return results
				}
			}
		}

		cache.SetTTL(cacheKey, results, ttl)
		return results
	}).Interface()
}

func makeCachePrefix(resultTypes []reflect.Type) string {
	builder := strings.Builder{}
	for _, resultType := range resultTypes {
		if resultType.ConvertibleTo(errorType) {
			continue
		}
		if builder.Len() > 0 {
			builder.WriteString(":")
		}
		builder.WriteString(resultType.Elem().Name())
	}
	return builder.String()
}

func makeCacheKey(args []reflect.Value) string {
	builder := strings.Builder{}
	for _, arg := range args {
		if arg.CanConvert(contextType) {
			continue
		}
		if builder.Len() > 0 {
			builder.WriteString(":")
		}
		if arg.CanConvert(cacheKeyProviderType) {
			builder.WriteString(arg.Convert(cacheKeyProviderType).Interface().(Cacheable).CacheKey())
		}
	}
	return builder.String()
}
